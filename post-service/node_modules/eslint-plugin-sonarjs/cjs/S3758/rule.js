"use strict";
/*
 * SonarQube JavaScript Plugin
 * Copyright (C) 2011-2024 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the Sonar Source-Available License Version 1, as published by SonarSource SA.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the Sonar Source-Available License for more details.
 *
 * You should have received a copy of the Sonar Source-Available License
 * along with this program; if not, see https://sonarsource.com/license/ssal/
 */
// https://sonarsource.github.io/rspec/#/rspec/S3758/javascript
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.rule = void 0;
const typescript_1 = __importDefault(require("typescript"));
const index_js_1 = require("../helpers/index.js");
const meta_js_1 = require("./meta.js");
const comparisonOperators = new Set(['>', '<', '>=', '<=']);
exports.rule = {
    meta: (0, index_js_1.generateMeta)(meta_js_1.meta, {
        messages: {
            reEvaluateDataFlow: 'Re-evaluate the data flow; this operand of a numeric comparison could be of type {{type}}.',
        },
    }),
    create(context) {
        const services = context.sourceCode.parserServices;
        if (!(0, index_js_1.isRequiredParserServices)(services)) {
            return {};
        }
        return {
            BinaryExpression(node) {
                const { left, operator, right } = node;
                if (!comparisonOperators.has(operator)) {
                    return;
                }
                if (left.type === 'MemberExpression' || right.type === 'MemberExpression') {
                    // avoid FPs on field access
                    return;
                }
                const checker = services.program.getTypeChecker();
                const leftType = (0, index_js_1.getTypeFromTreeNode)(left, services);
                const rightType = (0, index_js_1.getTypeFromTreeNode)(right, services);
                if ((0, index_js_1.isStringType)(leftType) || (0, index_js_1.isStringType)(rightType)) {
                    return;
                }
                const isLeftConvertibleToNumber = isConvertibleToNumber(leftType, checker);
                const isRightConvertibleToNumber = isConvertibleToNumber(rightType, checker);
                if (!isLeftConvertibleToNumber) {
                    context.report({
                        messageId: 'reEvaluateDataFlow',
                        data: {
                            type: checker.typeToString(leftType),
                        },
                        node: left,
                    });
                }
                if (!isRightConvertibleToNumber) {
                    context.report({
                        messageId: 'reEvaluateDataFlow',
                        data: {
                            type: checker.typeToString(rightType),
                        },
                        node: right,
                    });
                }
            },
        };
    },
};
function isConvertibleToNumber(typ, checker) {
    const flags = typ.getFlags();
    if ((flags & typescript_1.default.TypeFlags.BooleanLike) !== 0) {
        return true;
    }
    if ((flags & typescript_1.default.TypeFlags.Undefined) !== 0) {
        return false;
    }
    const valueOfSignatures = getValueOfSignatures(typ, checker);
    return (valueOfSignatures.length === 0 ||
        valueOfSignatures.some(signature => {
            const returnType = signature.getReturnType();
            return (0, index_js_1.isNumberType)(returnType) || (0, index_js_1.isBigIntType)(returnType);
        }));
}
function getValueOfSignatures(typ, checker) {
    const valueOfSymbol = typ.getProperty('valueOf');
    if (!valueOfSymbol) {
        return [];
    }
    const declarations = valueOfSymbol.getDeclarations() ?? [];
    return declarations
        .map(declaration => checker.getTypeAtLocation(declaration).getCallSignatures())
        .reduce((result, decl) => result.concat(decl), []);
}
