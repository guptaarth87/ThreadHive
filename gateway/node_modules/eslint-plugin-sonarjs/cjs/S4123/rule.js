"use strict";
/*
 * SonarQube JavaScript Plugin
 * Copyright (C) 2011-2024 SonarSource SA
 * mailto:info AT sonarsource DOT com
 *
 * This program is free software; you can redistribute it and/or
 * modify it under the terms of the Sonar Source-Available License Version 1, as published by SonarSource SA.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the Sonar Source-Available License for more details.
 *
 * You should have received a copy of the Sonar Source-Available License
 * along with this program; if not, see https://sonarsource.com/license/ssal/
 */
// https://sonarsource.github.io/rspec/#/rspec/S4123/javascript
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.rule = void 0;
const typescript_1 = __importDefault(require("typescript"));
const index_js_1 = require("../helpers/index.js");
const meta_js_1 = require("./meta.js");
exports.rule = {
    meta: (0, index_js_1.generateMeta)(meta_js_1.meta, {
        messages: {
            refactorAwait: "Refactor this redundant 'await' on a non-promise.",
        },
    }),
    create(context) {
        const services = context.sourceCode.parserServices;
        if ((0, index_js_1.isRequiredParserServices)(services)) {
            return {
                AwaitExpression: (node) => {
                    const awaitedType = (0, index_js_1.getTypeFromTreeNode)(node.argument, services);
                    if (!isException(node, services) &&
                        !isThenable(awaitedType) &&
                        !isAny(awaitedType) &&
                        !isUnknown(awaitedType) &&
                        !isUnion(awaitedType)) {
                        context.report({
                            messageId: 'refactorAwait',
                            node,
                        });
                    }
                },
            };
        }
        return {};
    },
};
/**
 * If the awaited expression is a call expression, check if it is a call to a function with
 * a JSDoc containing a return tag.
 */
function isException(node, services) {
    if (node.argument.type !== 'CallExpression') {
        return false;
    }
    const signature = (0, index_js_1.getSignatureFromCallee)(node.argument, services);
    return signature?.declaration && hasJsDocReturn(signature.declaration);
    function hasJsDocReturn(declaration) {
        const RETURN_TAGS = ['return', 'returns'];
        if (!declaration.jsDoc) {
            return false;
        }
        for (const jsDoc of declaration.jsDoc) {
            if (jsDoc.tags?.some(tag => RETURN_TAGS.includes(tag.tagName.escapedText.toString()))) {
                return true;
            }
        }
        return false;
    }
}
function isThenable(type) {
    const thenProperty = type.getProperty('then');
    return thenProperty?.declarations?.some(d => d.kind === typescript_1.default.SyntaxKind.MethodSignature ||
        d.kind === typescript_1.default.SyntaxKind.MethodDeclaration ||
        d.kind === typescript_1.default.SyntaxKind.PropertyDeclaration);
}
function isAny(type) {
    return Boolean(type.flags & typescript_1.default.TypeFlags.Any);
}
function isUnknown(type) {
    return Boolean(type.flags & typescript_1.default.TypeFlags.Unknown);
}
function isUnion(type) {
    return Boolean(type.flags & typescript_1.default.TypeFlags.Union);
}
